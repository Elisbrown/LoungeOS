import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import { format } from 'date-fns';
import { Order } from '@/context/order-context';
import { InventoryItem } from '@/lib/db/inventory';

// Define the type for autoTable since it extends jsPDF
interface jsPDFWithAutoTable extends jsPDF {
  lastAutoTable: {
    finalY: number;
  };
}

interface UserInfo {
    name: string;
    email: string;
    address?: string;
    phone?: string;
}

interface Settings {
    organizationName: string;
    contactAddress: string;
    contactPhone: string;
    platformLogo?: string;
}

const getBase64Image = async (url: string): Promise<string> => {
    try {
        const response = await fetch(url);
        if (!response.ok) return '';
        
        if (typeof window !== 'undefined' && typeof FileReader !== 'undefined') {
            const blob = await response.blob();
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result as string);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        } else {
            // Server side (Node.js)
            const arrayBuffer = await response.arrayBuffer();
            const buffer = Buffer.from(arrayBuffer);
            const contentType = response.headers.get('content-type') || 'image/png';
            return `data:${contentType};base64,${buffer.toString('base64')}`;
        }
    } catch (e) {
        console.error('Failed to get base64 image:', e);
        return '';
    }
};

const addUniversalHeaderAndFooter = async (doc: jsPDF, title: string, userInfo?: UserInfo, settings?: Settings) => {
    const pageWidth = doc.internal.pageSize.width;
    const pageHeight = doc.internal.pageSize.height;
    
    const totalPages = (doc as any).internal.getNumberOfPages();
    
    for (let i = 1; i <= totalPages; i++) {
        doc.setPage(i);
        
        // --- HEADER ---
        // Right side: Info about who generated it
        doc.setFontSize(9);
        doc.setTextColor(100);
        const rightX = pageWidth - 14;
        if (userInfo) {
            doc.text(`Generated by: ${userInfo.name}`, rightX, 12, { align: 'right' });
        }
        doc.text(`Date: ${format(new Date(), 'PPP p')}`, rightX, 17, { align: 'right' });

        // Left side: Logo and Organization Info
        let leftContentY = 12;
        if (settings) {
            if (settings.platformLogo) {
                try {
                    const base64Logo = await getBase64Image(settings.platformLogo);
                    if (base64Logo) {
                        doc.addImage(base64Logo, 'PNG', 14, 8, 10, 10);
                        leftContentY = 22; // Push text down if logo is present
                    }
                } catch (e) {}
            }
            
            doc.setFontSize(11);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(0);
            doc.text(settings.organizationName, 14, leftContentY);
            
            doc.setFontSize(8);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(100);
            doc.text(`${settings.contactAddress} | Tel: ${settings.contactPhone}`, 14, leftContentY + 4);
            
            leftContentY += 10;
        }

        doc.setFontSize(16);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(0);
        doc.text(title.toUpperCase(), 14, leftContentY);
        doc.line(14, leftContentY + 2, pageWidth - 14, leftContentY + 2);

        // --- FOOTER ---
        doc.setFontSize(8);
        doc.setTextColor(150);
        const footerText1 = "Software: LoungeOS | Developed by Sunyin Elisbrown (SIGALIX)";
        const footerText2 = "Contact: elisbrown@sigalix.net | +237 679 690 703 | sigalix.net";
        doc.text(footerText1, 14, pageHeight - 12);
        doc.text(footerText2, 14, pageHeight - 8);
        doc.text(`Page ${i} of ${totalPages}`, pageWidth - 14, pageHeight - 10, { align: 'right' });
    }
};
export const exportOrdersToPDF = async (orders: Order[], title: string = 'Orders Report', staff: any[] = [], userInfo?: UserInfo, settings?: Settings) => {
  const doc = new jsPDF() as jsPDFWithAutoTable;
  
  // Prepare table data
  const tableColumn = ["Order ID", "Table", "Status", "Items", "Total", "Date", "Notes"];
  const tableRows = orders.map(order => {
    const total = order.items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
    const itemsSummary = order.items.map(item => `${item.quantity}x ${item.name}`).join(', ');
    
    let notes = "";
    if (order.status === 'Canceled') {
        let staffName = "Unknown";
        if (order.cancelled_by) {
            const found = staff.find(s => parseInt(s.id) === order.cancelled_by);
            if (found) staffName = found.name;
        }
        notes = `Canceled by ${staffName}\nReason: ${order.cancellation_reason || 'N/A'}\nTime: ${order.cancelled_at ? format(new Date(order.cancelled_at), 'HH:mm') : ''}`;
    }

    return [
      order.id,
      order.table,
      order.status,
      itemsSummary,
      `XAF ${total.toLocaleString()}`,
      format(new Date(order.timestamp), 'PP p'),
      notes
    ];
  });

  // Generate table
  autoTable(doc, {
    head: [tableColumn],
    body: tableRows,
    startY: 45,
    theme: 'grid',
    styles: {
      fontSize: 8,
      cellPadding: 3,
      overflow: 'linebreak',
      valign: 'top'
    },
    headStyles: {
      fillColor: [41, 128, 185],
      textColor: 255,
      fontStyle: 'bold',
    },
    columnStyles: {
        6: { cellWidth: 40 } // Give more width to notes column
    },
    alternateRowStyles: {
      fillColor: [245, 245, 245],
    },
    margin: { top: 45, bottom: 20 }
  });

  await addUniversalHeaderAndFooter(doc, title, userInfo, settings);

  // Save the PDF
  doc.save(`orders_export_${format(new Date(), 'yyyy-MM-dd_HH-mm')}.pdf`);
};

/**
 * Export inventory items to PDF
 */
export const exportInventoryToPDF = async (items: InventoryItem[], title: string = 'Inventory Report', userInfo?: UserInfo, settings?: Settings) => {
  const doc = new jsPDF() as jsPDFWithAutoTable;
  
  // Prepare table data
  const tableColumn = ["SKU", "Name", "Category", "Stock", "Cost/Unit", "Status", "Supplier"];
  const tableRows = items.map(item => {
    return [
      item.sku,
      item.name,
      item.category,
      `${item.current_stock} ${item.unit}`,
      item.cost_per_unit ? `XAF ${item.cost_per_unit.toLocaleString()}` : '-',
      item.status,
      item.supplier?.name || '-'
    ];
  });

  // Generate table
  autoTable(doc, {
    head: [tableColumn],
    body: tableRows,
    startY: 45,
    theme: 'grid',
    styles: {
      fontSize: 9,
      cellPadding: 3,
    },
    headStyles: {
      fillColor: [46, 204, 113], // Green for inventory
      textColor: 255,
      fontStyle: 'bold',
    },
    alternateRowStyles: {
      fillColor: [245, 245, 245],
    },
    margin: { top: 45, bottom: 20 }
  });

  await addUniversalHeaderAndFooter(doc, title, userInfo, settings);

  // Save the PDF
  doc.save(`inventory_export_${format(new Date(), 'yyyy-MM-dd_HH-mm')}.pdf`);
};

/**
 * Export sales summary to PDF
 */
export const exportSalesSummaryToPDF = async (
    data: {
        chartData: { label: string; current: number }[];
        categorySales: { category: string; sales: number }[];
        recentSales: any[];
        staffPerformance: any[];
    }, 
    title: string = 'Sales Summary Report', 
    userInfo?: UserInfo,
    settings?: Settings
) => {
    const doc = new jsPDF() as jsPDFWithAutoTable;
    
    // Recent Transactions Table
    doc.setFontSize(12);
    doc.text("Recent Transactions", 14, 52);
    
    autoTable(doc, {
        head: [["ID", "Table", "Cashier", "Amount", "Date"]],
        body: data.recentSales.map(s => [s.id, s.table, s.cashier || 'N/A', `XAF ${s.total_amount.toLocaleString()}`, format(new Date(s.timestamp || Date.now()), 'PP p')]),
        startY: 55,
        theme: 'grid',
        margin: { top: 55, bottom: 20 }
    });

    // Staff Performance Table
    let currentY = (doc as any).lastAutoTable.finalY + 10;
    doc.setFontSize(12);
    doc.text("Staff Performance", 14, currentY);
    
    autoTable(doc, {
        head: [["Name", "Role", "Total Revenue"]],
        body: data.staffPerformance.map(s => [s.name, s.role, `XAF ${s.total_revenue.toLocaleString()}`]),
        startY: currentY + 5,
        theme: 'grid',
    });

    // Category Sales
    currentY = (doc as any).lastAutoTable.finalY + 10;
    doc.setFontSize(12);
    doc.text("Category Breakdown", 14, currentY);
    
    autoTable(doc, {
        head: [["Category", "Sales Value"]],
        body: data.categorySales.map(c => [c.category, `XAF ${c.sales.toLocaleString()}`]),
        startY: currentY + 5,
        theme: 'grid',
    });

    await addUniversalHeaderAndFooter(doc, title, userInfo, settings);

    doc.save(`sales_summary_${format(new Date(), 'yyyy-MM-dd_HH-mm')}.pdf`);
};

